module test_kramers_kronig
    use funit
    use constants, only: zero, one, real12, tolerance, pi, two
    use definedtypes
    use greensroutines
    use kramers_kronig_relations, only: hilbert_transform

    implicit none

contains

    @before
    subroutine set_up()
    end subroutine set_up

    @after
    subroutine tear_down()
    end subroutine tear_down

    @test
    subroutine test_hilbert_transform_even()
        logical :: is_problem = .true.
        integer :: i, ierr = -1
        real(real12) :: frequency(10) = [(two*pi*real(i-1,real12)/10.0_real12, i=1, 10)]
        real(real12) :: test(size(frequency))
        real(real12) :: expected(size(frequency))
        real(real12) :: result(size(frequency))

        test = input(frequency)
        expected = output(frequency)

        call hilbert_transform(test, result, ierr)
        @assertEqual(0, ierr)

        if (all(abs(result - expected) <= tolerance)) is_problem = .false.

        do i = 1, size(frequency)
            write (666, *) frequency(i), test(i), result(i), expected(i)
        end do

        @assertFalse(is_problem)

    contains

        elemental function input(value)
            real(real12) :: input
            real(real12), intent(in) :: value
            input = sin(value)
        end function input

        elemental function output(value)
            real(real12) :: output
            real(real12), intent(in) :: value
            output = sin(value - pi/two)
        end function output

    end subroutine test_hilbert_transform_even

    @test
    subroutine test_hilbert_transform_odd()
        logical :: is_problem = .true.
        integer :: i, ierr = -1
        real(real12) :: frequency(11) = [(two*pi*real(i-1,real12)/11.0_real12, i=1, 11)]
        real(real12) :: test(size(frequency))
        real(real12) :: expected(size(frequency))
        real(real12) :: result(size(frequency))

        test = input(frequency)
        expected = output(frequency)

        call hilbert_transform(test, result, ierr)
        @assertEqual(0, ierr)

        if (all(abs(result - expected) <= tolerance)) is_problem = .false.

        @assertFalse(is_problem)

    contains

        elemental function input(value)
            real(real12) :: input
            real(real12), intent(in) :: value
            input = sin(value)
        end function input

        elemental function output(value)
            real(real12) :: output
            real(real12), intent(in) :: value
            output = sin(value - pi/two)
        end function output

    end subroutine test_hilbert_transform_odd

    @test
    subroutine hilbert_trans_array_match()
        real(real12) :: input(3)
        real(real12) :: output(2)
        integer :: ierr = -1

        input = zero
        output = zero
        call hilbert_transform(input, output, ierr)
        @assertEqual(1, ierr)
    end subroutine hilbert_trans_array_match

    @test
    subroutine hilbert_trans_nonperiodic()
        integer :: i, ierr
        integer, parameter :: npoints = 20
        real(real12) :: test(npoints)
        real(real12) :: result(npoints), expected(npoints)
        real(real12) :: timegrid(npoints) = [(real(i-1,real12), i=1, npoints)]
        logical :: is_problem = .true.

        test = real_values(timegrid)
        expected = hilbert_values(timegrid)

        call hilbert_transform(test, result, ierr)
        @assertEqual(0, ierr)

        if (all(abs(result - expected) <= tolerance)) is_problem = .false.

        @assertFalse(is_problem)

    contains

        elemental function real_values(time)
            real(real12) :: real_values
            real(real12), intent(in) :: time

            real_values = one/(time*time + one)
        end function real_values    

        elemental function hilbert_values(time)
            real(real12) :: hilbert_values
            real(real12), intent(in) :: time

            hilbert_values = time/(time*time + one)
        end function hilbert_values

    end subroutine hilbert_trans_nonperiodic

    ! @test
    ! subroutine kramers_kronig_greensfunction()
    !     integer, parameter :: kpoints=5, n_omega=10
    !     integer :: i, ierr
    !     real(real12) :: density(kpoints, kpoints, kpoints, n_omega)
    !     real(real12), parameter :: frequency(n_omega) = [(two*pi*real(i-1,real12)/real(n_omega, real12), i=1, nomega)]
    !     type(greensfunc) :: calculation(kpoints,kpoints,kpoints)
    !     type(greensfunc) :: expected(kpoints,kpoints,kpoints)

    !     call GF_allocate(calculation, n_omega)
    !     call GF_allocate(expected, n_omega)



    !     contains

    !         function initialise_density(input)
    !             real(real12) :: initialise_density
    !             real(real12) :: input

    !         end function initialise_density

    !         function expected_value(input)
    !             complex(real12) :: expected_value
    !             real(real12) :: input

    !         end function expected_value

    ! end subroutine kramers_kronig_greensfunction


end module
