module test_matrix_inversion
    use funit
    use constants
    use greensroutines
    use matrix_methods

    implicit none

contains

    @before
    subroutine set_up()
    end subroutine set_up

    @after
    subroutine tear_down()
    end subroutine tear_down

    @test
    subroutine diagonal_matrix()
        complex(real12) :: input_matrix(20,20)
        complex(real12) :: output_matrix(20,20)
        complex(real12) :: test_output(20,20)
        integer :: ierr = 1
        integer :: i

        input_matrix = cmplx_zero
        output_matrix = cmplx_zero
        test_output = cmplx_zero

        do concurrent (i = 1:20)
            input_matrix(i,i)%re = real(i, real12)
            test_output(i,i)%re = one/real(i, real12)
        end do

        call invert_diagonal_mat(input_matrix, output_matrix, ierr)
        @assertEqual(ierr, 0)
        @assertEqual(output_matrix, test_output, tolerance)

    end subroutine diagonal_matrix

    @test
    subroutine diagonal_sing()
        complex(real12) :: input_matrix(20,20)
        complex(real12) :: output_matrix(20,20)
        integer :: ierr = 0
        integer :: i

        input_matrix = cmplx_zero
        output_matrix = cmplx_zero

        do concurrent (i = 1:20)
            input_matrix(i,i)%re = real(i, real12)
        end do
        input_matrix(2,2) = cmplx_zero

        call invert_diagonal_mat(input_matrix, output_matrix, ierr)

        @assertFalse(ierr == 0)

    end subroutine diagonal_sing    

    @test
    subroutine nondiagonal_matrix()
        complex(real12) :: input_matrix(5,5)
        complex(real12) :: inverted_matrix(5,5)
        complex(real12) :: product_matrix(5,5)
        complex(real12) :: identity_matrix(5,5)
        integer :: ierr = 1
        integer :: i, j

        input_matrix = cmplx_zero
        inverted_matrix = cmplx_zero
        product_matrix = cmplx_zero
        identity_matrix = cmplx_zero

        do concurrent (i = 1:5)
            identity_matrix(i,i) = one
            input_matrix(i,i) = two
        enddo 
            input_matrix(2,1) = one
            input_matrix(5,4) = one

        call invert_general_matrix(input_matrix, inverted_matrix, ierr)
        @assertEqual(ierr, 0)

        product_matrix = matmul(input_matrix, inverted_matrix)

        @assertEqual(product_matrix, identity_matrix, tolerance)        

    end subroutine nondiagonal_matrix

    @test
    subroutine diag_GF_matrix()
        type(greensfunc) :: input_matrix(20,20)
        type(greensfunc) :: output_matrix(20,20)
        type(greensfunc) :: test_output(20,20)
        complex(real12) :: output_slice(20,20,2)
        complex(real12) :: test_slice(20,20,2)
        complex(real12) :: temp_slice(20,20)
        complex(real12), parameter :: initialise(20,20) = cmplx_zero
        integer :: i_matrix(20,20)
        integer :: i, j

        call allocate_GF(input_matrix, 2)
        call allocate_GF(output_matrix, 2)
        call allocate_GF(test_output, 2)
        
        call initialise_GF(input_matrix, initialise)
        call initialise_GF(output_matrix, initialise)
        call initialise_GF(test_output, initialise)

        do concurrent (i = 1:20, j = 1:2)
            input_matrix(i,i)%GF(j)%re = real(i, real12)
            test_output(i,i)%GF(j)%re = one/real(i, real12)
        end do

        call invert_GF_matrix(input_matrix, output_matrix)

        do i = 1, 2
            i_matrix = i
            call copy_gf_slice(output_slice(1:20,1:20, i), output_matrix, i_matrix)
            call copy_gf_slice(test_slice(1:20,1:20, i), test_output, i_matrix)
        end do
        
        @assertEqual(output_slice, test_slice, tolerance)
    end subroutine

    ! @test
    ! subroutine nondiag_GF_matrix()
    ! end subroutine

    ! @test
    ! subroutine mixed_GF_matrix()
    ! end subroutine


end module test_matrix_inversion